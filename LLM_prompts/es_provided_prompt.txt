**Background**: When using version control systems like Git, a merge conflict occurs when two branches independently modify the same base version of a file, and these modifications are either spatially overlapping or adjacent. A conflicting file may contain multiple independent conflict hunks.
Core Concept: Edit Script
An "edit script" represents an atomic, line-level code change that precisely describes a specific modification from the base version to either the target branch or the source branch.

Formally, it is represented by a tuple (os, oe, ms, me), where:

[os, oe): The start and end lines (in a half-open interval, where the oe line is excluded) of the change in the base code.
[ms, me): The start and end lines of the change in the modified code (e.g., the target branch or source branch).

For example, an edit script can be:

Deletion: (5, 7, 5, 5) indicates that the code in the interval [5, 7) is deleted (where ms = me).
Insertion: (5, 5, 10, 12) indicates that the code in the interval [10, 12) is inserted after line 5 of the base code.
Modification: (5, 7, 10, 12) indicates that the code in the interval [5, 7) of the base code is modified to the code in the interval [10, 12).

A conflict chunk typically contains multiple such edit scripts from both the target branch and the source branch, and these scripts are either adjacent or overlapping in terms of line numbers in the base code.

**Role**: You are a professional code conflict merger assistant, proficient in helping developers understand complex code conflict structures. Especially in scenarios where differences among multiple versions (current branch, common ancestor, and other branch) coexist, you can accurately resolve code conflict merging issues.

**Task**:  Your task is to resolve the merge conflicts in a section of code. The analysis materials include the complete code from base, ours, and theirs, as well as the edit scripts generated for each conflict block. You need to analyze the modification intentions of the developers in each edit script, infer why the developers made such modifications. Generate the final conflict - free solution code.

**Output Format: Answer only with the content after the resolution of each conflict block. No other additional content is allowed, including comments, analysis, and newly generated code from hallucinations.Output the merged results of each conflict block in sequence and strictly follow the output format in the example.

**Instruction**: Maintain code consistency, formatting, and React best practices.

# For example:
## Prompt 1:
base:
using ConnectApp.components;\nusing ConnectApp.components.pull_to_refresh;\nusing ConnectApp.models;\nusing ConnectApp.Models.ActionModel;\nusing ConnectApp.Models.ViewModel;\nusing ConnectApp.redux.actions;\nusing RSG;\nusing Unity.UIWidgets.foundation;\nusing Unity.UIWidgets.Redux;\nusing Unity.UIWidgets.scheduler;\nusing Unity.UIWidgets.widgets;\n\nnamespace ConnectApp.screens\n{\n    \n    public class EventCompletedScreenConnector : StatelessWidget {\n        public override Widget build(BuildContext context) {\n            return new StoreConnector<AppState, EventsScreenViewModel>(\n                converter: state => new EventsScreenViewModel {\n                    eventCompletedLoading = state.eventState.eventsCompletedLoading,\n                    completedEvents = state.eventState.completedEvents,\n                    completedEventTotal = state.eventState.completedEventTotal,\n                    eventsDict = state.eventState.eventsDict,\n                    placeDict = state.placeState.placeDict\n                },\n                builder: (context1, viewModel, dispatcher) => {\n                    var actionModel = new EventsScreenActionModel {\n                        pushToEventDetail = (eventId, eventType) => dispatcher.dispatch(\n                            new MainNavigatorPushToEventDetailAction {\n                                eventId = eventId, eventType = eventType\n                            }),\n                        StartFetchEventCompletedAction = () => dispatcher.dispatch(new StartFetchEventCompletedAction()),\n                        fetchEvents = (pageNumber, tab) =>\n                            dispatcher.dispatch<IPromise>(Actions.fetchEvents(pageNumber, tab))\n                    };\n                    return new EventCompletedScreen(viewModel, actionModel);\n                });\n        }\n    }\n    \n    \n    public class EventCompletedScreen : StatefulWidget\n    {\n        public EventCompletedScreen(\n            EventsScreenViewModel viewModel = null,\n            EventsScreenActionModel actionModel = null,\n            Key key = null\n        ) : base(key) {\n            this.viewModel = viewModel;\n            this.actionModel = actionModel;\n        }\n        public readonly EventsScreenViewModel viewModel;\n        public readonly EventsScreenActionModel actionModel;\n        \n        public override State createState()\n        {\n            return new _EventCompletedScreenState();\n        }\n    }\n\n    public class _EventCompletedScreenState : AutomaticKeepAliveClientMixin<EventCompletedScreen>\n    {\n        private const int firstPageNumber = 1;\n        private RefreshController _completedRefreshController;\n        private int pageNumber = firstPageNumber;\n        protected override bool wantKeepAlive\n        {\n            get => false;\n        }\n\n        public override void initState()\n        {\n            base.initState();\n            _completedRefreshController = new RefreshController();\n            SchedulerBinding.instance.addPostFrameCallback(_ => {\n                widget.actionModel.StartFetchEventCompletedAction();\n                widget.actionModel.fetchEvents(pageNumber, \"completed\");\n            });\n        }\n\n        public override Widget build(BuildContext context)\n        {\n            if (widget.viewModel.eventCompletedLoading) return new GlobalLoading();\n            return new SmartRefresher(\n                controller: _completedRefreshController,\n                enablePullDown: true,\n                enablePullUp: widget.viewModel.completedEvents.Count < widget.viewModel.completedEventTotal,\n                headerBuilder: (cxt, mode) => new SmartRefreshHeader(mode),\n                footerBuilder: (cxt, mode) => new SmartRefreshHeader(mode),\n                onRefresh: _completedRefresh,\n                child: ListView.builder(\n                    itemExtent:108,\n                    physics: new AlwaysScrollableScrollPhysics(),\n                    itemCount: widget.viewModel.completedEvents.Count,\n                    itemBuilder: (cxt, index) => {\n                        var eventId = widget.viewModel.completedEvents[index];\n                        var model = widget.viewModel.eventsDict[eventId];\n                        var place = model.placeId.isEmpty() ? null : widget.viewModel.placeDict[model.placeId];\n                        return new EventCard(\n                            model,\n                            place,\n                            () => widget.actionModel.pushToEventDetail(\n                                model.id,\n                                model.mode == \"online\" ? EventType.onLine : EventType.offline\n                            ),\n                            new ObjectKey(model.id)\n                        );\n                    }\n                )\n            );\n        }\n        private void _completedRefresh(bool up) {\n            if (up)\n                pageNumber = 1;\n            else\n                pageNumber++;\n            widget.actionModel.fetchEvents(pageNumber, \"completed\")\n                .Then(() => _completedRefreshController.sendBack(up, up ? RefreshStatus.completed : RefreshStatus.idle))\n                .Catch(_ => _completedRefreshController.sendBack(up, RefreshStatus.failed));\n        }\n    }\n}
ours:
using ConnectApp.components;\nusing ConnectApp.components.pull_to_refresh;\nusing ConnectApp.models;\nusing ConnectApp.Models.ActionModel;\nusing ConnectApp.Models.ViewModel;\nusing ConnectApp.redux.actions;\nusing RSG;\nusing Unity.UIWidgets.foundation;\nusing Unity.UIWidgets.Redux;\nusing Unity.UIWidgets.scheduler;\nusing Unity.UIWidgets.widgets;\n\nnamespace ConnectApp.screens {\n    public class EventCompletedScreenConnector : StatelessWidget {\n        public override Widget build(BuildContext context) {\n            return new StoreConnector<AppState, EventsScreenViewModel>(\n                converter: state => new EventsScreenViewModel {\n                    eventCompletedLoading = state.eventState.eventsCompletedLoading,\n                    completedEvents = state.eventState.completedEvents,\n                    completedEventTotal = state.eventState.completedEventTotal,\n                    eventsDict = state.eventState.eventsDict,\n                    placeDict = state.placeState.placeDict\n                },\n                builder: (context1, viewModel, dispatcher) => {\n                    var actionModel = new EventsScreenActionModel {\n                        pushToEventDetail = (eventId, eventType) => dispatcher.dispatch(\n                            new MainNavigatorPushToEventDetailAction {\n                                eventId = eventId, eventType = eventType\n                            }),\n                        startFetchEventCompleted = () => dispatcher.dispatch(new StartFetchEventCompletedAction()),\n                        fetchEvents = (pageNumber, tab) =>\n                            dispatcher.dispatch<IPromise>(Actions.fetchEvents(pageNumber, tab))\n                    };\n                    return new EventCompletedScreen(viewModel, actionModel);\n                }\n            );\n        }\n    }\n    \n    public class EventCompletedScreen : StatefulWidget {\n        public EventCompletedScreen(\n            EventsScreenViewModel viewModel = null,\n            EventsScreenActionModel actionModel = null,\n            Key key = null\n        ) : base(key) {\n            this.viewModel = viewModel;\n            this.actionModel = actionModel;\n        }\n        public readonly EventsScreenViewModel viewModel;\n        public readonly EventsScreenActionModel actionModel;\n        \n        public override State createState() {\n            return new _EventCompletedScreenState();\n        }\n    }\n\n    public class _EventCompletedScreenState : AutomaticKeepAliveClientMixin<EventCompletedScreen> {\n        private const int firstPageNumber = 1;\n        private RefreshController _completedRefreshController;\n        private int pageNumber = firstPageNumber;\n        protected override bool wantKeepAlive {\n            get => false;\n        }\n\n        public override void initState() {\n            base.initState();\n            _completedRefreshController = new RefreshController();\n            SchedulerBinding.instance.addPostFrameCallback(_ => {\n                widget.actionModel.startFetchEventCompleted();\n                widget.actionModel.fetchEvents(firstPageNumber, \"completed\");\n            });\n        }\n\n        public override Widget build(BuildContext context) {\n            if (widget.viewModel.eventCompletedLoading && widget.viewModel.completedEvents.isEmpty()) return new GlobalLoading();\n            if (widget.viewModel.completedEvents.Count <= 0) return new BlankView(\"暂无往期活动\");\n            return new SmartRefresher(\n                controller: _completedRefreshController,\n                enablePullDown: true,\n                enablePullUp: widget.viewModel.completedEvents.Count < widget.viewModel.completedEventTotal,\n                headerBuilder: (cxt, mode) => new SmartRefreshHeader(mode),\n                footerBuilder: (cxt, mode) => new SmartRefreshHeader(mode),\n                onRefresh: _completedRefresh,\n                child: ListView.builder(\n                    itemExtent: 108,\n                    physics: new AlwaysScrollableScrollPhysics(),\n                    itemCount: widget.viewModel.completedEvents.Count,\n                    itemBuilder: (cxt, index) => {\n                        var eventId = widget.viewModel.completedEvents[index];\n                        var model = widget.viewModel.eventsDict[eventId];\n                        var place = model.placeId.isEmpty() ? null : widget.viewModel.placeDict[model.placeId];\n                        return new EventCard(\n                            model,\n                            place,\n                            () => widget.actionModel.pushToEventDetail(\n                                model.id,\n                                model.mode == \"online\" ? EventType.online : EventType.offline\n                            ),\n                            new ObjectKey(model.id)\n                        );\n                    }\n                )\n            );\n        }\n        private void _completedRefresh(bool up) {\n            if (up)\n                pageNumber = firstPageNumber;\n            else\n                pageNumber++;\n            widget.actionModel.fetchEvents(pageNumber, \"completed\")\n                .Then(() => _completedRefreshController.sendBack(up, up ? RefreshStatus.completed : RefreshStatus.idle))\n                .Catch(_ => _completedRefreshController.sendBack(up, RefreshStatus.failed));\n        }\n    }\n}
theirs:
using ConnectApp.components;\nusing ConnectApp.components.pull_to_refresh;\nusing ConnectApp.models;\nusing ConnectApp.Models.ActionModel;\nusing ConnectApp.Models.ViewModel;\nusing ConnectApp.redux.actions;\nusing RSG;\nusing Unity.UIWidgets.foundation;\nusing Unity.UIWidgets.Redux;\nusing Unity.UIWidgets.scheduler;\nusing Unity.UIWidgets.widgets;\n\nnamespace ConnectApp.screens\n{\n    \n    public class EventCompletedScreenConnector : StatelessWidget {\n        public override Widget build(BuildContext context) {\n            return new StoreConnector<AppState, EventsScreenViewModel>(\n                converter: state => new EventsScreenViewModel {\n                    eventCompletedLoading = state.eventState.eventsCompletedLoading,\n                    completedEvents = state.eventState.completedEvents,\n                    completedEventTotal = state.eventState.completedEventTotal,\n                    eventsDict = state.eventState.eventsDict,\n                    placeDict = state.placeState.placeDict\n                },\n                builder: (context1, viewModel, dispatcher) => {\n                    var actionModel = new EventsScreenActionModel {\n                        pushToEventDetail = (eventId, eventType) => dispatcher.dispatch(\n                            new MainNavigatorPushToEventDetailAction {\n                                eventId = eventId, eventType = eventType\n                            }),\n                        StartFetchEventCompletedAction = () => dispatcher.dispatch(new StartFetchEventCompletedAction()),\n                        fetchEvents = (pageNumber, tab) =>\n                            dispatcher.dispatch<IPromise>(Actions.fetchEvents(pageNumber, tab))\n                    };\n                    return new EventCompletedScreen(viewModel, actionModel);\n                });\n        }\n    }\n    \n    \n    public class EventCompletedScreen : StatefulWidget\n    {\n        public EventCompletedScreen(\n            EventsScreenViewModel viewModel = null,\n            EventsScreenActionModel actionModel = null,\n            Key key = null\n        ) : base(key) {\n            this.viewModel = viewModel;\n            this.actionModel = actionModel;\n        }\n        public readonly EventsScreenViewModel viewModel;\n        public readonly EventsScreenActionModel actionModel;\n        \n        public override State createState()\n        {\n            return new _EventCompletedScreenState();\n        }\n    }\n\n    public class _EventCompletedScreenState : State<EventCompletedScreen>\n    {\n        private const int firstPageNumber = 1;\n        private RefreshController _completedRefreshController;\n        private int pageNumber = firstPageNumber;\n\n        public override void initState()\n        {\n            base.initState();\n            _completedRefreshController = new RefreshController();\n            SchedulerBinding.instance.addPostFrameCallback(_ => {\n                widget.actionModel.StartFetchEventCompletedAction();\n                widget.actionModel.fetchEvents(pageNumber, \"completed\");\n            });\n        }\n\n        public override Widget build(BuildContext context)\n        {\n            if (widget.viewModel.eventCompletedLoading) return new GlobalLoading();\n            if (widget.viewModel.completedEvents.isEmpty())\n            {\n                return new BlankView(\"暂无即将开始的活动\");\n            }\n            return new SmartRefresher(\n                controller: _completedRefreshController,\n                enablePullDown: true,\n                enablePullUp: widget.viewModel.completedEvents.Count < widget.viewModel.completedEventTotal,\n                headerBuilder: (cxt, mode) => new SmartRefreshHeader(mode),\n                footerBuilder: (cxt, mode) => new SmartRefreshHeader(mode),\n                onRefresh: _completedRefresh,\n                child: ListView.builder(\n                    itemExtent:108,\n                    physics: new AlwaysScrollableScrollPhysics(),\n                    itemCount: widget.viewModel.completedEvents.Count,\n                    itemBuilder: (cxt, index) => {\n                        var eventId = widget.viewModel.completedEvents[index];\n                        var model = widget.viewModel.eventsDict[eventId];\n                        var place = model.placeId.isEmpty() ? null : widget.viewModel.placeDict[model.placeId];\n                        return new EventCard(\n                            model,\n                            place,\n                            () => widget.actionModel.pushToEventDetail(\n                                model.id,\n                                model.mode == \"online\" ? EventType.onLine : EventType.offline\n                            ),\n                            new ObjectKey(model.id)\n                        );\n                    }\n                )\n            );\n        }\n        private void _completedRefresh(bool up) {\n            if (up)\n                pageNumber = 1;\n            else\n                pageNumber++;\n            widget.actionModel.fetchEvents(pageNumber, \"completed\")\n                .Then(() => _completedRefreshController.sendBack(up, up ? RefreshStatus.completed : RefreshStatus.idle))\n                .Catch(_ => _completedRefreshController.sendBack(up, RefreshStatus.failed));\n        }\n    }\n}
edit script(base, ours):
SequenceDiff(12, 15, 12, 13)
SequenceDiff(31, 32, 29, 30)
SequenceDiff(36, 37, 34, 36)
SequenceDiff(40, 43, 39, 40)
SequenceDiff(54, 56, 51, 52)
SequenceDiff(60, 62, 56, 57)
SequenceDiff(65, 67, 60, 61)
SequenceDiff(70, 72, 64, 65)
SequenceDiff(75, 77, 68, 70)
SequenceDiff(80, 83, 73, 76)
SequenceDiff(91, 92, 84, 85)
SequenceDiff(103, 104, 96, 97)
SequenceDiff(113, 114, 106, 107)
edit script(base, theirs):
SequenceDiff(60, 61, 60, 61)
SequenceDiff(65, 69, 65, 65)
SequenceDiff(83, 83, 79, 83)
file_m_content:
<<<<<<< /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/c0ffb354-5519-4f20-a961-3fc964feaf34.ts\n||||||| /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/7a2f8714-70de-4c90-91e8-7b2c7a09f928.ts\nimport admin from '../db/firebase.client';\nconst blogFireStoreClient = admin.firestore();\n=======\nimport admin from '../db/firebase.client';\n>>>>>>> /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/2d367464-c8ad-4d9a-804b-63266f2ff31f.ts\nimport { Blog } from '../../projects/shared-library/src/lib/shared/model';\nimport admin from '../db/firebase.client';\n\nexport class BlogService {\n<<<<<<< /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/c0ffb354-5519-4f20-a961-3fc964feaf34.ts\n\n    private static blogFireStoreClient = admin.firestore();\n\n||||||| /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/7a2f8714-70de-4c90-91e8-7b2c7a09f928.ts\n\n=======\n  private static blogFireStoreClient = admin.firestore();\n>>>>>>> /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/2d367464-c8ad-4d9a-804b-63266f2ff31f.ts\n    /**\n     * setBlog\n     * return ref\n     */\n    static async setBlog(blogs: Array<Blog>): Promise<any> {\n<<<<<<< /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/c0ffb354-5519-4f20-a961-3fc964feaf34.ts\n        const batch = this.blogFireStoreClient.batch();\n||||||| /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/7a2f8714-70de-4c90-91e8-7b2c7a09f928.ts\n        const batch = blogFireStoreClient.batch();\n=======\n        try {\n        const batch = this.blogFireStoreClient.batch();\n>>>>>>> /mnt/batch/tasks/workitems/adfv2-General_1/job-1/c7b5984d-1bc7-4d42-a282-0fca338489da/wd/.temp/athenacommon/2d367464-c8ad-4d9a-804b-63266f2ff31f.ts\n        for (const blog of blogs) {\n            const pub_date = new Date(blog.pubDate).getTime() + '';\n            blog.id = Number(pub_date);\n            const blogInstance = this.blogFireStoreClient.collection('blogs').doc(pub_date);\n            batch.set(blogInstance, blog);\n        }\n            return await batch.commit();\n        } catch (error) {\n            console.error('Error : ', error);\n            throw error;\n        }\n    }\n}

## Completion 1:
### MERGE_RESULT_START 1 ###
    public class _EventCompletedScreenState : State<EventCompletedScreen> {\n
### MERGE_RESULT_END 1 ###

### MERGE_RESULT_START 2 ###
### MERGE_RESULT_END 2 ###

### MERGE_RESULT_START 3 ###
        public override Widget build(BuildContext context) {\n            if (widget.viewModel.eventCompletedLoading && widget.viewModel.completedEvents.isEmpty()) return new GlobalLoading();\n            if (widget.viewModel.completedEvents.Count <= 0) return new BlankView(\"暂无往期活动\");\n
### MERGE_RESULT_END 3 ###